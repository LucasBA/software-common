#!/usr/bin/python

import numpy

import struct

import roslib
roslib.load_manifest('nv08c_driver')

import rospy
from std_msgs.msg import String, Header
from geometry_msgs.msg import Vector3

from skytraq_driver import gps
from rawgps_common.msg import Measurements, Satellite

rospy.init_node('dump', anonymous=True)

class MyEphemeris(gps.Ephemeris):
    def __init__(self):
        pass

ephs = {}

antenna_pos = None

pub = rospy.Publisher('/gps', Measurements)

def cb(msg):
    global antenna_pos
    if msg.data.startswith('\xf5'):
        msg = msg.data[1:]
        t_ms, week, gpsutc, glonassutc, timecorr = struct.unpack('<dHddb', msg[:27])
        #print 'RAW', t, week, gpsutc, glonassutc, timecorr
        assert len(msg[27:]) % 30 == 0
        m = Measurements(
            header=Header(
                stamp=rospy.Time.now(),
                frame_id='/gps',
            ),
            satellites=[],
        )
        for i in xrange(len(msg[27:]) // 30):
            d = msg[27+30*i:27+30*i+30]
            sig_type, sat_num, carrier_num, snr, carrier_phase, pseudo_range, doppler_freq, flags, res = struct.unpack('<BBBBdddBB', d)
            #print '   ', sig_type, sat_num, carrier_num, snr, carrier_phase, pseudo_range, doppler_freq, flags, res
            if sig_type == 0x02:
                if antenna_pos is not None and sat_num in ephs:
                    eph = ephs[sat_num]
                    t = t_ms/1000 + gpsutc/1000
                    measured_vel = doppler_freq*gps.c/gps.L1_f0
                    sat_vel = -gps.deriv(lambda t: numpy.linalg.norm(antenna_pos-eph.predict(t)), t)
                    sat_pos = eph.predict(t)
                    sat_dir = sat_pos - antenna_pos;sat_dir /= numpy.linalg.norm(sat_dir)
                    print sat_num, sat_vel, measured_vel-108
                    m.satellites.append(Satellite(
                        direction_enu=Vector3(*gps.enu_from_ecef(sat_dir, antenna_pos)),
                        velocity_plus_drift=measured_vel - sat_vel,
                        prn=sat_num,
                        cn0=snr,
                    ))
        print
        pub.publish(m)
    elif msg.data.startswith('\x88'):
        lat, lon, alt, err, t, week, lat_vel, lon_vel, alt_vel, dev, status = struct.unpack('<dddf10shdddfB', msg.data[1:])
        #print 'PVT', lat, lon, alt, err, None, week, lat_vel, lon_vel, alt_vel, dev, status
    elif msg.data.startswith('\xf6'):
        x, y, z, x_err, y_err, z_err, flags = struct.unpack('<ddddddB', msg.data[1:])
        #print 'GCA', x, y, z, x_err, y_err, z_err, flags
        antenna_pos = numpy.array([x, y, z])
    elif msg.data.startswith('\x70'):
        channels, description, serial, res1, res2, res3, res4 = struct.unpack('<B21sI21sI21sI', msg.data[1:])
        #print 'VER', channels, description, serial, res1, res2, res3, res4
    elif msg.data.startswith('\x4a'):
        a0, a1, a2, a3, b0, b1, b2, b3, reliable = struct.unpack('<ffffffffB', msg.data[1:])
        #print 'ION', a0, a1, a2, a3, b0, b1, b2, b3, reliable
    elif msg.data.startswith('\x4b'):
        A1, A0, t_ot, WN_t, dt_LS, WN_LSF, DN, dt_LSF, reliable, NA, tau_C, glonass_reliable = struct.unpack('<ddIHhHHhBHdB', msg.data[1:])
        #print 'TSP', A1, A0, t_ot, WN_t, dt_LS, WN_LSF, DN, dt_LSF, reliable, NA, tau_C, glonass_reliable
    elif msg.data.startswith('\xe7'):
        (data_type,), value = struct.unpack('<B', msg.data[1]), msg.data[2:]
        #print 'AOP', data_type, value.encode('hex')
    elif msg.data.startswith('\xf7'):
        sat_type, sat_num = struct.unpack('<BB', msg.data[1:3])
        if sat_type == 1: # GPS
            Crs, Dn, M0, Cuc, E, Cus, SqrtA, Toe, Cic, Omega0, Cis, I0, Crc, W, OmegaR, Ir, Tgd, Toc, Af2, Af1, Af0, URA, IODE, IODC, CodeL2, L2_Pdata_flag, WeekN = struct.unpack('<ffdfdfddfdfdfdddfdfffHHHHHH', msg.data[3:])
            #print 'EPH', sat_num, Crs, Dn, M0, Cuc, E, Cus, SqrtA, Toe, Cic, Omega0, Cis, I0, Crc, W, OmegaR, Ir, Tgd, Toc, Af2, Af1, Af0, URA, IODE, IODC, CodeL2, L2_Pdata_flag, WeekN
            eph = MyEphemeris()
            eph.C_rs, eph.delta_n, eph.M_0, eph.C_uc, eph.e, eph.C_us, eph.sqrt_A, eph.t_oe, eph.C_ic, eph.omega_0, eph.C_is, eph.i_0, eph.C_rc, eph.omega, eph.omega_dot, eph.IDOT, eph.t_gd, eph.t_oc, eph.a_f2, eph.a_f1, eph.a_f0, eph.URA, eph.IODE, eph.IODC = Crs, Dn*1000, M0, Cuc, E, Cus, SqrtA, Toe/1000, Cic, Omega0, Cis, I0, Crc, W, OmegaR*1000, Ir*1000, Tgd/1000, Toc/1000, Af2*1000, Af1, Af0/1000, URA, IODE, IODC
            #print sat_num, eph
            #print eph.predict(0)
            ephs[sat_num] = eph
        elif sat_type == 2: # GLONASS
            carrier, X, Y, Z, Vx, Vy, Vz, Ax, Ay, Az, t_b, gamma_n_of_t_b, tau_n_of_t_b, E_n = struct.unpack('<bddddddddddffH', msg.data[3:])
            #print 'GPH', carrier, X, Y, Z, Vx, Vy, Vz, Ax, Ay, Az, t_b, gamma_n_of_t_b, tau_n_of_t_b, E_n
        else:
            print 'unknown sat_type', sat_type
    else:
        print msg.data.encode('hex'), len(msg.data)
rospy.Subscriber('/gps_serial', String, cb)

rospy.spin()
