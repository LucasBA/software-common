#!/usr/bin/env python

from __future__ import division

import numpy
import scipy.optimize

import roslib
roslib.load_manifest('thruster_mapper')
import rospy
from geometry_msgs.msg import WrenchStamped
from std_msgs.msg import Header
import tf
from tf import transformations

from uf_common.orientation_helpers import xyz_array
from thruster_handling.listener import ThrusterListener


rospy.init_node('thruster_mapper')


# listen for wrenches and send out ThrusterCommand messages
tf_listener = tf.TransformListener()
thruster_listener = ThrusterListener()

def lstsq_box(A, b, x_mins, x_maxs):
    return scipy.optimize.fmin_slsqp(
        func=lambda x: numpy.linalg.norm(A.dot(x) - b)**2,
        x0=(x_mins + x_maxs)/2,
        bounds=zip(x_mins, x_maxs),
        fprime=lambda x: 2*A.T.dot(A.dot(x) - b),
        disp=0,
    )

def wrench_callback(msg):
    wrench = numpy.concatenate([xyz_array(msg.wrench.force), xyz_array(msg.wrench.torque)])
    
    # get thrusterinfos that haven't expired
    good_thrusterinfos = []
    for ti in thruster_listener.get_thrusters():
        try:
            trans, rot_q = tf_listener.lookupTransform(
                msg.header.frame_id, ti.header.frame_id, msg.header.stamp)
        except Exception, e:
            rospy.logerr("lookupTransform failed: %s", e)
            continue
        rot = transformations.quaternion_matrix(rot_q)[:3, :3]
        
        good_thrusterinfos.append((
            ti, # thrusterinfo
            trans + rot.dot(xyz_array(ti.position)), # position in wrench frame
            rot.dot(transformations.unit_vector(xyz_array(ti.direction))), # direction in wrench frame
        ))
    
    if not good_thrusterinfos:
        return
    
    wrench_from_efforts = numpy.array([numpy.concatenate([
        direction, # force = direction * effort
        numpy.cross(position, direction), # torque = (position X direction) * effort
    ]) for ti, position, direction in good_thrusterinfos]).T
    
    # solve for efforts using box-constrained least squares
    efforts = lstsq_box(wrench_from_efforts, wrench,
        numpy.array([ti[0].min_force for ti in good_thrusterinfos]),
        numpy.array([ti[0].max_force for ti in good_thrusterinfos]))
    
    error = numpy.linalg.norm(wrench_from_efforts.dot(efforts) - wrench)
    if error > 0.01: # N
        rospy.loginfo("Thruster efforts don't exactly match desired wrench. Error: %.2f N", error)
    
    for (ti, _, _), effort in zip(good_thrusterinfos, efforts):
        thruster_listener.send_command(ti.id, effort)
rospy.Subscriber('wrench', WrenchStamped, wrench_callback)


rospy.spin()
