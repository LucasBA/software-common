#!/usr/bin/env python

from __future__ import division

import math

import numpy

import roslib
roslib.load_manifest('kalman_6dof')
roslib.load_manifest('gps_common')
import rospy
from geometry_msgs.msg import WrenchStamped, Wrench, Vector3, Twist, Pose, Point, Quaternion, PoseStamped, PoseWithCovariance, TwistWithCovariance, Vector3Stamped
from std_msgs.msg import Header
from nav_msgs.msg import Odometry
from gps_common.msg import GPSFix
from tf import transformations
import tf


rospy.init_node('gps_to_odom', anonymous=True)


def ecef_from_latlongheight(latitude, longitude, height):
    # WGS 84
    a = 6378137.0
    f = 1/298.257223563
    
    e = 2*f - f**2
    
    N = a/math.sqrt(1 - e**2*math.sin(latitude)**2)
    return numpy.array([
        (N + height)*math.cos(latitude)*math.cos(longitude),
        (N + height)*math.cos(latitude)*math.sin(longitude),
        (N*(1 - e**2) + height)*math.sin(latitude),
    ])

pub = rospy.Publisher('gps_odom', Odometry)
velpub = rospy.Publisher('gps_vel', Vector3Stamped)
prev_msg_position = None
prev_msg_track = None
prev_relpos = None
prev_ts = None

start_pos = None

def callback(msg):
    global prev_msg_position, prev_msg_track, prev_relpos, prev_ts
    # gpsd_client seems to send duplicate messages ... filter them out
    if msg.latitude == prev_msg_position and msg.track == prev_msg_track:
        print 'ignored!'
        return
    
    pos = ecef_from_latlongheight(
        math.radians(msg.latitude),
        math.radians(msg.longitude),
        msg.altitude,
    )
    global start_pos
    if start_pos is None:
        start_pos = pos
    
    up_ecef = transformations.unit_vector(start_pos)
    east_ecef = transformations.unit_vector(numpy.cross([0, 0, 1], up_ecef))
    north_ecef = numpy.cross(up_ecef, east_ecef)
    enu_from_ecef = numpy.array([east_ecef, north_ecef, up_ecef])
    
    relpos = enu_from_ecef.dot(pos - start_pos)
    
    
    vel = numpy.array([
        msg.speed * math.sin(math.radians(msg.track)),
        msg.speed * math.cos(math.radians(msg.track)),
        msg.climb if not math.isnan(msg.climb) else 0,
    ])
    if prev_relpos is not None:
        vel2 = (relpos - prev_relpos)/(msg.header.stamp - prev_ts).to_sec()
        if msg.track == prev_msg_track:
            print 'differentiating'
            a = msg.speed * transformations.unit_vector(vel2[0:2])
            vel = numpy.concatenate([a, vel[2:]])
    
    #print pos
    print relpos, vel
    
    pub.publish(Odometry(
        header=Header(
            stamp=msg.header.stamp,
            frame_id='/map',
        ),
        child_frame_id='/gps',
        pose=PoseWithCovariance(
            pose=Pose(
                position=Point(*relpos),
                orientation=Quaternion(0, 0, 0, 1),
            ),
            covariance=numpy.diag([1, 2, 3, 1e10, 1e10, 1e10]).flatten(),
        ),
        twist=TwistWithCovariance(
            twist=Twist(
                linear=Vector3(*vel), # XXX should be in child_frame_id frame
                angular=Vector3(0, 0, 0),
            ),
            covariance=numpy.diag([1, 2, 3, 1e10, 1e10, 1e10]).flatten(),
        ),
    ))
    velpub.publish(Vector3Stamped(
        header=Header(
            stamp=msg.header.stamp,
            frame_id='/map',
        ),
        vector=Vector3(*vel),
    ))
    
    prev_msg_position = msg.latitude
    prev_msg_track = msg.track
    prev_ts = msg.header.stamp
    prev_relpos = relpos
rospy.Subscriber('extended_fix', GPSFix, callback)

rospy.spin()
