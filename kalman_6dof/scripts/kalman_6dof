#!/usr/bin/env python

import math
import threading

import numpy

import roslib
roslib.load_manifest('kalman_6dof')
import rospy
from sensor_msgs.msg import Imu
from nav_msgs.msg import Odometry
from geometry_msgs.msg import Point, Quaternion, Vector3, Vector3Stamped, PoseStamped
import tf
from tf import transformations

from kalman_6dof import kalman, triad, util


_lock = threading.Lock()
def callWithLock(func, *args, **kwargs):
    with _lock:
        func(*args, **kwargs)

debug = False

xyz_array = lambda o: numpy.array([o.x, o.y, o.z])
normalized = lambda x: x/numpy.linalg.norm(x)



k = None

count = 0
def got_imu(msg):
    # only use every tenth input
    global count
    count += 1
    count %= 10
    if count != 1:
       return
    
    global k, k_frame
    oldk = k
    
    if k is not None and (msg.header.stamp < k.t or msg.header.stamp - k.t > rospy.Duration(1)):
        # reset if timestamp goes backwards at all or forwards by more than a second
        k = None
        return
    
    if k is None and mag_buffer is not None and gps_buffer is not None:
        # initialize filter
        k_frame = msg.header.frame_id
        k = kalman.Kalman(
            t=msg.header.stamp,
            position=gps_buffer[0:3],
            velocity_body=numpy.zeros(3),
            orientation=triad.triad(
                (-kalman.G, north),
                (xyz_array(msg.linear_acceleration), mag_buffer),
            ),
            P=numpy.diag([100, 100, 100, 10, 10, 10, 1e-3, 1e-3, 1e-3])**2,
            angular_velocity_body=xyz_array(msg.angular_velocity),
            angular_velocity_body_cov=numpy.array(msg.angular_velocity_covariance).reshape((3, 3)),
            acceleration_felt_body=xyz_array(msg.linear_acceleration),
            acceleration_felt_body_cov=numpy.array(msg.linear_acceleration_covariance).reshape((3, 3)),
        )
    elif k is not None:
        # predict using imu data
        assert msg.header.frame_id == k_frame
        k = k.predict(
            t=msg.header.stamp,
            angular_velocity_body=xyz_array(msg.angular_velocity),
            angular_velocity_body_cov=100*numpy.array(msg.angular_velocity_covariance).reshape((3, 3)),
            acceleration_felt_body=xyz_array(msg.linear_acceleration),
            acceleration_felt_body_cov=100*numpy.array(msg.linear_acceleration_covariance).reshape((3, 3)),
        )
    else:
        return
    
    
    if hack_down_ref and oldk is not None:
        # correct orientation there are no long accelerations
        # not necessary with a velocity or position reference
        
        world_from_body = transformations.quaternion_matrix(k.orientation)[:3, :3]
        
        #assert k.t == msg.header.stamp
        dt = (k.t - oldk.t).to_sec()
        
        print numpy.linalg.norm(xyz_array(msg.linear_acceleration))
        if numpy.linalg.norm(kalman.G) / 1.02 < numpy.linalg.norm(xyz_array(msg.linear_acceleration)) < numpy.linalg.norm(kalman.G) * 1.02 and dt > 0:
            #print 'correcting'
            predicted_acceleration_felt = -kalman.G
            predicted_acceleration_felt_body = world_from_body.T.dot(predicted_acceleration_felt)
            J = numpy.zeros((3, 9))
            J[0:3, 3:6] = world_from_body.T.dot(util.skewmatrix(predicted_acceleration_felt))
            #print J
            #print 'predicted', predicted_acceleration_felt_body
            #print 'actual', xyz_array(msg.linear_acceleration)
            #print 'error', xyz_array(msg.linear_acceleration) - predicted_acceleration_felt_body
            if debug: print 'XXX accel'
            k = k.update(xyz_array(msg.linear_acceleration) - predicted_acceleration_felt_body, J, .01**2*numpy.identity(3)/dt, name='grv')
            
            world_from_body = transformations.quaternion_matrix(k.orientation)[:3, :3]
            predicted_acceleration_felt_body = world_from_body.T.dot(predicted_acceleration_felt)
            #print 'corrected', predicted_acceleration_felt_body
            #print 'corrected'
            if debug: print 'STA', k.position, k.orientation, k.velocity
            if debug: print 'VAR', numpy.diag(k.P)
            if debug: print 'ANG', map(math.degrees, transformations.euler_from_quaternion(k.orientation))
            if debug: print 'end'
        else:
            if debug:
                print 'ignored acceleration'
    
    publish()


def compose_transforms((p1, q1), (p2, q2)):
    r1 = transformations.quaternion_matrix(q1)[:3, :3]
    #r2 = transformations.quaternion_matrix(q2)[:3, :3]
    # y = p1 + r1 * (p2 + r2 * x)
    # y = (p1 + r1 * p2) + (r1 * r2) * x
    return p1 + r1.dot(p2), transformations.quaternion_multiply(q1, q2)

def invert_transform((p, q)):
    r = transformations.quaternion_matrix(q)[:3, :3]
    # y = p + r * x
    # y - p = r * x
    # r^-1 * (y - p) = x
    # r^-1 * -p + r^-1 * y = x
    return r.T.dot(-numpy.array(p)), transformations.quaternion_conjugate(q)

def publish():
    out = Odometry()
    out.header.stamp = k.t
    out.header.frame_id = fixed_frame
    out.child_frame_id = body_frame
    
    world_from_imu_tf = k.position, k.orientation
    try:
        imu_from_body_tf = tf_listener.lookupTransform(k_frame, body_frame, k.t)
    except Exception, e:
        rospy.logerr('publish lookupTransform failed: %s', e)
        return
    world_from_body_tf = compose_transforms(world_from_imu_tf, imu_from_body_tf)
    body_from_imu_tf = invert_transform(imu_from_body_tf)
    
    out.pose.pose.position = Point(*world_from_body_tf[0])
    out.pose.pose.orientation = Quaternion(*world_from_body_tf[1])
    out.pose.covariance = k.P[0:6, 0:6].flatten() # XXX wrong since not transformed from imu to world
    
    
    imu_from_body = transformations.quaternion_matrix(imu_from_body_tf[1])[:3, :3]
    
    out.twist.twist.linear = Vector3(*imu_from_body.T.dot(k.velocity_body) + numpy.cross(k.angular_velocity_body, numpy.array(imu_from_body_tf[0])))
    out.twist.twist.angular = Vector3(*imu_from_body.T.dot(k.angular_velocity_body))
    twist_covariance = numpy.zeros((6, 6))
    twist_covariance[0:3, 0:3] = k.P[6:9, 6:9]; twist_covariance[0:3, 3:6] = 0 # XXX not actually zero
    twist_covariance[3:6, 0:3] = 0; twist_covariance[3:6, 3:6] = k.angular_velocity_body_cov
    out.twist.covariance = twist_covariance.flatten()
    
    pub.publish(out)
    
    
    out = PoseStamped()
    out.header.stamp = k.t
    out.header.frame_id = fixed_frame
    
    out.pose.position = Point(*world_from_body_tf[0])
    out.pose.orientation = Quaternion(*world_from_body_tf[1])
    pub2.publish(out)
    
    #tf_broadcaster.sendTransform(world_from_body_tf[0], world_from_body_tf[1], k.t, body_frame, fixed_frame)


mag_buffer = None
count2 = 0
def got_mag(msg):
    global mag_buffer, k
    
    # only use every tenth input
    global count2
    count2 += 1
    count2 %= 10
    if count2 != 1:
       return
    
    my = mag_buffer = xyz_array(msg.vector)
    
    if k is None: return # hasn't been initialized yet
    
    #assert k.t == msg.header.stamp
    
    assert msg.header.frame_id == k_frame
    
    imu_from_world = transformations.quaternion_matrix(k.orientation).T[:3, :3]
    
    predicted_mag = north
    predicted_mag_imu = imu_from_world.dot(predicted_mag)
    J = numpy.zeros((3, 9))
    J[0:3, 3:6] = imu_from_world.dot(util.skewmatrix(predicted_mag))
    
    k = k.update(my - predicted_mag_imu, J, numpy.diag([1e-3, 1e-3, 1e-3])**2, name='mag')


gps_buffer = None
def got_gps(msg):
    global gps_buffer, k
    
    debug = 1
    
    my = gps_buffer = numpy.concatenate([xyz_array(msg.pose.pose.position), xyz_array(msg.twist.twist.linear)])
    
    if k is None: return # hasn't been initialized yet
    
    #assert k.t == msg.header.stamp
    # XXX use transform
    
    world_from_imu = transformations.quaternion_matrix(k.orientation)[:3, :3]
    
    predicted = numpy.concatenate([k.position, world_from_imu.dot(k.velocity_body)])
    J = numpy.zeros((6, 9))
    J[0:3, 0:3] = numpy.identity(3)
    J[3:6, 3:6] = util.skewmatrix(world_from_imu.dot(k.velocity_body)).T
    J[3:6, 6:9] = world_from_imu
    
    if debug: print 'XXX gps'
    if debug: print 'pre', k.position, k.velocity_body, k.orientation
    if debug: print 'gps', 'measured', my, 'thought', predicted
    k = k.update(my - predicted, J, numpy.diag(numpy.array([.15, .15, .15, .01, .01, .01])**2), name='gps')
    if debug: print 'post', k.position, k.velocity_body, k.orientation
    if debug: print 'STA', k.position, k.velocity_body, k.orientation
    if debug: print 'VAR', numpy.diag(k.P)
    if debug: print 'ANG', map(math.degrees, transformations.euler_from_quaternion(k.orientation))
    if debug: print 'end'


rospy.init_node('kalman_6dof')

body_frame = rospy.get_param('~body_frame', '/base_link')
fixed_frame = rospy.get_param('~fixed_frame', '/map')
hack_down_ref = rospy.get_param('~hack_down_ref')
north = numpy.array([-0.022442e-4, 0.241510e-4, -0.405728e-4])*1e4 # gauss

tf_listener = tf.TransformListener()
tf_broadcaster = tf.TransformBroadcaster()

rospy.Subscriber('/imu/data_raw', Imu, lambda msg: callWithLock(got_imu, msg))
rospy.Subscriber('/imu/mag', Vector3Stamped, lambda msg: callWithLock(got_mag, msg))
rospy.Subscriber('gps_odom', Odometry, lambda msg: callWithLock(got_gps, msg))
pub = rospy.Publisher('ins', Odometry)
pub2 = rospy.Publisher('ins2', PoseStamped)

rospy.spin()
