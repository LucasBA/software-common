#!/usr/bin/env python

import math
import threading

import numpy

import roslib
roslib.load_manifest('kalman_6dof')
import rospy
from sensor_msgs.msg import Imu
from nav_msgs.msg import Odometry
from geometry_msgs.msg import Point, Quaternion, Vector3, Vector3Stamped, PoseStamped
import tf
from tf import transformations

from uf_common.msg import Float64Stamped
from uf_common.orientation_helpers import triad, xyz_array


from kalman_6dof import kalman


_lock = threading.Lock()
def callWithLock(func, *args, **kwargs):
    with _lock:
        func(*args, **kwargs)

debug = False

k = None

count = 0
def got_imu(msg):
    # only use every tenth input
    global count
    count += 1
    count %= 10
    if count != 1:
       return
    
    global k, k_frame
    oldk = k
    
    if k is not None and (msg.header.stamp < k.t or msg.header.stamp - k.t > rospy.Duration(1)):
        # reset if timestamp goes backwards at all or forwards by more than a second
        k = None
        return
    
    if k is None and mag_buffer is not None:
        # initialize filter
        k_frame = msg.header.frame_id
        k = kalman.Kalman(
            t=msg.header.stamp,
            position=numpy.zeros(3),
            velocity_body=numpy.zeros(3),
            orientation=triad(
                (-kalman.G, north),
                (xyz_array(msg.linear_acceleration), mag_buffer),
            ),
            clock_drift=0,
            P=numpy.diag([0, 0, 0, 1e-2, 1e-2, 1e-2, 10, 10, 10, 10000])**2,
            angular_velocity_body=xyz_array(msg.angular_velocity),
            angular_velocity_body_cov=numpy.array(msg.angular_velocity_covariance).reshape((3, 3)),
            acceleration_felt_body=xyz_array(msg.linear_acceleration),
            acceleration_felt_body_cov=numpy.array(msg.linear_acceleration_covariance).reshape((3, 3)),
        )
    elif k is not None:
        # predict using imu data
        assert msg.header.frame_id == k_frame
        k = k.predict(
            t=msg.header.stamp,
            angular_velocity_body=xyz_array(msg.angular_velocity),
            angular_velocity_body_cov=10*numpy.array(msg.angular_velocity_covariance).reshape((3, 3)),
            acceleration_felt_body=xyz_array(msg.linear_acceleration),
            acceleration_felt_body_cov=10*numpy.array(msg.linear_acceleration_covariance).reshape((3, 3)),
        )
    else:
        return
    
    
    if hack_down_ref and oldk is not None:
        # correct orientation assuming there are no long accelerations
        # not necessary with a velocity or position reference
        
        world_from_body = transformations.quaternion_matrix(k.orientation)[:3, :3]
        
        #assert k.t == msg.header.stamp
        dt = (k.t - oldk.t).to_sec()
        
        print numpy.linalg.norm(xyz_array(msg.linear_acceleration))
        if numpy.linalg.norm(kalman.G) / 1.02 < numpy.linalg.norm(xyz_array(msg.linear_acceleration)) < numpy.linalg.norm(kalman.G) * 1.02 and dt > 0:
            #print 'correcting'
            predicted_acceleration_felt = -kalman.G
            predicted_acceleration_felt_body = world_from_body.T.dot(predicted_acceleration_felt)
            J = numpy.zeros((3, 9))
            J[0:3, 3:6] = world_from_body.T.dot(kalman.skewmatrix(predicted_acceleration_felt))
            #print J
            #print 'predicted', predicted_acceleration_felt_body
            #print 'actual', xyz_array(msg.linear_acceleration)
            #print 'error', xyz_array(msg.linear_acceleration) - predicted_acceleration_felt_body
            if debug: print 'XXX accel'
            k = k.update(xyz_array(msg.linear_acceleration) - predicted_acceleration_felt_body, J, .01**2*numpy.identity(3)/dt, name='grv')
            
            world_from_body = transformations.quaternion_matrix(k.orientation)[:3, :3]
            predicted_acceleration_felt_body = world_from_body.T.dot(predicted_acceleration_felt)
            #print 'corrected', predicted_acceleration_felt_body
            #print 'corrected'
            if debug: print 'STA', k.position, k.orientation, k.velocity
            if debug: print 'VAR', numpy.diag(k.P)
            if debug: print 'ANG', map(math.degrees, transformations.euler_from_quaternion(k.orientation))
            if debug: print 'end'
        else:
            if debug:
                print 'ignored acceleration'
    
    publish()

def publish():
    out = Odometry()
    out.header.stamp = k.t
    out.header.frame_id = fixed_frame
    out.child_frame_id = k_frame
    
    out.pose.pose.position = Point(*k.position)
    out.pose.pose.orientation = Quaternion(*k.orientation)
    out.pose.covariance = k.P[0:6, 0:6].flatten()
    
    out.twist.twist.linear = Vector3(*k.velocity_body)
    out.twist.twist.angular = Vector3(*k.angular_velocity_body)
    twist_covariance = numpy.zeros((6, 6))
    twist_covariance[0:3, 0:3] = k.P[6:9, 6:9]; twist_covariance[0:3, 3:6] = 0 # XXX not actually zero
    twist_covariance[3:6, 0:3] = 0; twist_covariance[3:6, 3:6] = k.angular_velocity_body_cov
    out.twist.covariance = twist_covariance.flatten()
    
    pub.publish(out)
    
    
    out = PoseStamped()
    out.header.stamp = k.t
    out.header.frame_id = fixed_frame
    
    out.pose.position = Point(*k.position)
    out.pose.orientation = Quaternion(*k.orientation)
    pub2.publish(out)


mag_buffer = None
count2 = 0
def got_mag(msg):
    global mag_buffer, k
    
    # only use every tenth input
    global count2
    count2 += 1
    count2 %= 10
    if count2 != 1:
       return
    
    my = mag_buffer = xyz_array(msg.vector)
    
    if k is None: return # hasn't been initialized yet
    
    #assert k.t == msg.header.stamp
    
    assert msg.header.frame_id == k_frame
    
    imu_from_world = transformations.quaternion_matrix(k.orientation).T[:3, :3]
    
    predicted_mag = north
    predicted_mag_imu = imu_from_world.dot(predicted_mag)
    J = numpy.zeros((3, 10))
    J[0:3, 3:6] = imu_from_world.dot(kalman.skewmatrix(predicted_mag))
    
    k = k.update(my - predicted_mag_imu, J, numpy.diag([1e-6, 1e-6, 1e-6])**2)#, name='mag')


def got_gps(msg):
    global k
    
    debug = 0
    
    direction_enu = xyz_array(msg.direction_enu)
    velocity_plus_drift = msg.velocity_plus_drift
    
    if k is None: return # hasn't been initialized yet
    try:
        tf_pos, tf_rot = tf_listener.lookupTransform(msg.header.frame_id, k_frame, msg.header.stamp) # dvl from imu
    except Exception, e:
        rospy.logerr('dvl lookupTransform failed: %s', e)
        return
    
    #assert k.t == msg.header.stamp
    # XXX use transform
    
    world_from_imu = transformations.quaternion_matrix(k.orientation)[:3, :3]
    predicted = direction_enu.dot(world_from_imu).dot(k.velocity_body + numpy.cross(k.angular_velocity_body, -numpy.array(tf_pos))) + k.clock_drift
    J = numpy.zeros((1, 10))
    J[0, 3:6] = direction_enu.dot(kalman.skewmatrix(world_from_imu.dot(k.velocity_body)).T)
    J[0, 6:9] = direction_enu.dot(world_from_imu)
    J[0,   9] = 1
    #print J
    
    error = velocity_plus_drift - predicted
    #print k.clock_drift, math.sqrt(k.P[9,9])
    if abs(error) > .5 and math.sqrt(k.P[9,9]) < .05:
        print error, direction_enu
        return
    
    k = k.update(velocity_plus_drift - predicted, J, numpy.diag(numpy.array([.01])**2))#, name='gps')
    if debug: print 'post gps', k.velocity_body, k.clock_drift

dvl_buffer = None
def got_dvl(msg):
    global dvl_buffer, k
    my = dvl_buffer = xyz_array(msg.vector)
    
    #assert k.t == msg.header.stamp
    
    if k is None: return
    try:
        tf_pos, tf_rot = tf_listener.lookupTransform(msg.header.frame_id, k_frame, msg.header.stamp) # dvl from imu
    except Exception, e:
        rospy.logerr('dvl lookupTransform failed: %s', e)
        return
    
    imu_from_world = transformations.quaternion_matrix(k.orientation).T[:3, :3]
    dvl_from_imu = transformations.quaternion_matrix(tf_rot)[:3, :3]
    predicted = dvl_from_imu.dot(k.velocity_body + numpy.cross(k.angular_velocity_body, -numpy.array(tf_pos)))
    
    J = numpy.zeros((3, 10))
    J[0:3, 3:6] = dvl_from_imu.dot(imu_from_world).dot(kalman.skewmatrix(imu_from_world.T.dot(k.velocity_body)))
    J[0:3, 6:9] = dvl_from_imu
    
    k = k.update(my - predicted, J, numpy.diag([.001, .001, .001])**2, name='dvl')

depth_buffer = None
def got_depth(msg):
    global depth_buffer, k
    my = depth_buffer = msg.data
    
    
    if k is None: return

    #assert k.t == msg.header.stamp
    # XXX use transform
    if debug: print 'XXX depth'
    if debug: print 'depth', 'measured', my, 'thought', -k.position[2]
    if debug: print 'pre', k.position, k.velocity, k.orientation
    k = k.update(my - (-k.position[2]), numpy.array([[0, 0, -1, 0, 0, 0, 0, 0, 0, 0]]), numpy.array([[.1**2]]), name='dep')
    if debug: print 'post', k.position, k.velocity, k.orientation

    if debug: print 'STA', k.position, k.velocity, k.orientation
    if debug: print 'VAR', numpy.diag(k.P)
    if debug: print 'ANG', map(math.degrees, transformations.euler_from_quaternion(k.orientation))
    if debug: print 'end'


rospy.init_node('kalman_6dof')

fixed_frame = rospy.get_param('~fixed_frame', '/map')
hack_down_ref = rospy.get_param('~hack_down_ref')
north = numpy.array([-2244.2, 24151.0, -40572.8])*1e-9

tf_listener = tf.TransformListener()
tf_broadcaster = tf.TransformBroadcaster()

pub = rospy.Publisher('ins', Odometry)
pub2 = rospy.Publisher('ins2', PoseStamped)

rospy.Subscriber('/imu/data_raw', Imu, lambda msg: callWithLock(got_imu, msg))
rospy.Subscriber('/imu/mag', Vector3Stamped, lambda msg: callWithLock(got_mag, msg))
from skytraq_driver.msg import Measurement
rospy.Subscriber('gps_measurements', Measurement, lambda msg: callWithLock(got_gps, msg))
rospy.Subscriber('dvl', Vector3Stamped, lambda msg: callWithLock(got_dvl, msg))
rospy.Subscriber('depth', Float64Stamped, lambda msg: callWithLock(got_depth, msg))

rospy.spin()
