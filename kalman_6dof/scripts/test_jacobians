#!/usr/bin/env python

from __future__ import division

import numpy

import roslib
roslib.load_manifest('kalman_6dof')
import rospy

from kalman_6dof.kalman import Kalman

k = Kalman(rospy.Time(0), numpy.zeros(3), numpy.array([0, 0, 0, 1]), numpy.zeros(3), 1000*numpy.identity(9), numpy.zeros(3), numpy.zeros((3, 3)), numpy.zeros(3), numpy.zeros((3, 3)))
gc = .1**2 * numpy.identity(3) # .1 rad/sec
ac = .1**2 * numpy.identity(3) # .1 m/s^2
k = k._predict(rospy.Time(.01), [1, 2, 3], gc, [4, 5, 6], ac, k.t)
k = k._predict(rospy.Time(.02), [1, 2, 3], gc, [4, 5, 6], ac, k.t)
measurement_t = rospy.Time(.025)
base, F, L = k._predict(rospy.Time(.03), [1., 2, 3], gc, [4., 5, 6], ac, measurement_t, _return_debug_matrices=True)

F_measured = numpy.zeros((9, 9))
L_measured = numpy.zeros((9, 6))
for i in xrange(9 + 6):
    dx = numpy.zeros(9)
    dm = numpy.zeros(6)
    if i < 9:
        dx[i] = 1e-3
    else:
        dm[i-9] = 1e-3
    trial = k._apply_dx(dx)._predict(rospy.Time(.03), [1., 2, 3]+dm[:3], gc, [4., 5, 6]+dm[3:], ac, measurement_t)
    dp, do, dv = trial._get_dx(base)
    should = F.dot(dx) + L.dot(dm)
    
    print
    print i
    
    print
    print 'predicted'
    print should[0:3]
    print should[3:6]
    print should[6:9]
    print
    print 'actual'
    print dp
    print map(float, do)
    print dv
    
    actual = numpy.concatenate([dp, do, dv])
    print 1 + numpy.linalg.norm(should - actual) / numpy.linalg.norm(actual)
    print
    
    if i < 9:
        F_measured[:, i] = actual/dx[i]
    else:
        L_measured[:, i-9] = actual/dm[i-9]
